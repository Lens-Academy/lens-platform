---
phase: 06-chat-evaluation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - web_frontend/src/pages/promptlab/+Page.tsx
  - web_frontend/src/pages/promptlab/+title.ts
  - web_frontend/src/api/promptlab.ts
  - web_frontend/src/components/promptlab/FixtureBrowser.tsx
autonomous: true

must_haves:
  truths:
    - "Navigating to /promptlab renders the Prompt Lab page"
    - "Unauthenticated users are redirected to login"
    - "API client can fetch fixture list and individual fixtures"
    - "API client can stream regeneration and continuation responses"
    - "FixtureBrowser displays fixture names and modules from API"
    - "FixtureBrowser supports filtering by module name"
  artifacts:
    - path: "web_frontend/src/pages/promptlab/+Page.tsx"
      provides: "Vike route for /promptlab"
      exports: ["default"]
    - path: "web_frontend/src/pages/promptlab/+title.ts"
      provides: "Page title"
    - path: "web_frontend/src/api/promptlab.ts"
      provides: "API client for all Prompt Lab endpoints"
      exports: ["listFixtures", "loadFixture", "regenerateResponse", "continueConversation"]
    - path: "web_frontend/src/components/promptlab/FixtureBrowser.tsx"
      provides: "Fixture list with module filtering"
      exports: ["default"]
  key_links:
    - from: "web_frontend/src/api/promptlab.ts"
      to: "/api/promptlab/*"
      via: "fetchWithRefresh and fetch streaming"
      pattern: "api/promptlab"
    - from: "web_frontend/src/pages/promptlab/+Page.tsx"
      to: "web_frontend/src/components/promptlab/FixtureBrowser.tsx"
      via: "import"
      pattern: "import.*FixtureBrowser"
---

<objective>
Create the Prompt Lab frontend page, API client, and fixture browser component.

Purpose: Establish the frontend routing, data fetching layer, and initial fixture browsing UI so facilitators can navigate to /promptlab, see available fixtures, and select one to work with.

Output: Vike page at /promptlab, API client module, FixtureBrowser component with module filtering.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chat-evaluation/06-CONTEXT.md
@.planning/phases/06-chat-evaluation/06-RESEARCH.md
@.planning/phases/06-chat-evaluation/06-01-SUMMARY.md

@web_frontend/src/pages/facilitator/+Page.tsx
@web_frontend/src/pages/facilitator/+title.ts
@web_frontend/src/api/modules.ts
@web_frontend/src/api/fetchWithRefresh.ts
@web_frontend/src/hooks/useAuth.ts
@web_frontend/src/config.ts
@web_frontend/src/components/Layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API client for Prompt Lab</name>
  <files>web_frontend/src/api/promptlab.ts</files>
  <action>
    Create `web_frontend/src/api/promptlab.ts` -- the API client for all Prompt Lab endpoints. Follow the patterns established in `api/modules.ts`.

    **Types:**
    ```typescript
    export interface FixtureSummary {
      name: string;
      module: string;
      description: string;
    }

    export interface FixtureSystemPrompt {
      base: string;
      instructions: string;
    }

    export interface FixtureMessage {
      role: "user" | "assistant";
      content: string;
    }

    export interface Fixture {
      name: string;
      module: string;
      description: string;
      systemPrompt: FixtureSystemPrompt;
      previousContent: string;
      messages: FixtureMessage[];
    }

    export interface StreamEvent {
      type: "text" | "thinking" | "done" | "error";
      content?: string;
      message?: string;
    }
    ```

    **Functions:**

    1. `listFixtures()`: GET /api/promptlab/fixtures, returns `FixtureSummary[]`. Use `fetchWithRefresh` with credentials: "include". Throw on non-OK response.

    2. `loadFixture(name: string)`: GET /api/promptlab/fixtures/{encodeURIComponent(name)}, returns `Fixture`. Use `fetchWithRefresh` with credentials: "include". Throw on non-OK.

    3. `regenerateResponse(messages, systemPrompt, enableThinking)`: POST /api/promptlab/regenerate. Returns `AsyncGenerator<StreamEvent>`. Use the exact same SSE streaming pattern as `sendMessage()` in api/modules.ts:
       - Use `fetchWithRefresh` (NOT plain fetch) for the POST request with JSON body, credentials: "include"
       - Get `reader` from `res.body.getReader()`
       - Use TextDecoder to decode chunks
       - Split on `\n`, filter for lines starting with `data: `, parse JSON
       - Yield each parsed event
       - The function signature should be `async function*` (async generator)

    4. `continueConversation(messages, systemPrompt, enableThinking)`: POST /api/promptlab/continue. Same async generator streaming pattern as regenerateResponse.

    Import `API_URL` from `../config` and `fetchWithRefresh` from `./fetchWithRefresh`.
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-platform/ws2/web_frontend && npm run lint` -- must pass.
    Run `cd /home/penguin/code/lens-platform/ws2/web_frontend && npx tsc --noEmit --pretty` -- must pass (type checking).
  </verify>
  <done>
    API client at web_frontend/src/api/promptlab.ts exports listFixtures, loadFixture, regenerateResponse, and continueConversation. All types defined. SSE streaming uses the same pattern as the existing sendMessage() function. Linting and type checking pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Vike page and FixtureBrowser component</name>
  <files>
    web_frontend/src/pages/promptlab/+Page.tsx
    web_frontend/src/pages/promptlab/+title.ts
    web_frontend/src/components/promptlab/FixtureBrowser.tsx
  </files>
  <action>
    Create the Vike page route and the fixture browser component.

    **1. `web_frontend/src/pages/promptlab/+title.ts`:**
    ```typescript
    export default "Prompt Lab | Lens Academy";
    ```

    **2. `web_frontend/src/pages/promptlab/+Page.tsx`:**
    Follow the pattern from `pages/facilitator/+Page.tsx`:
    ```tsx
    import Layout from "@/components/Layout";
    import PromptLab from "@/views/PromptLab";

    export default function PromptLabPage() {
      return (
        <Layout>
          <PromptLab />
        </Layout>
      );
    }
    ```
    Note: The `PromptLab` view component doesn't exist yet (created in Plan 04). For now, create a minimal placeholder at `web_frontend/src/views/PromptLab.tsx` that:
    - Imports `useAuth` from `@/hooks/useAuth`
    - Checks authentication -- if not authenticated or loading, shows appropriate state (login redirect or loading spinner)
    - If authenticated, renders `<FixtureBrowser />` as the initial view
    - Has a `selectedFixture` state (null initially) that will be expanded in Plan 04
    - When a fixture is selected, for now just shows a placeholder "Fixture loaded: {name}" text (Plan 04 replaces this with the full two-panel layout)

    **3. `web_frontend/src/components/promptlab/FixtureBrowser.tsx`:**
    Per user decisions:
    - Simple list view as initial screen
    - Each fixture shows name and module
    - Filter/search by module name (dropdown or text filter)
    - Loading a fixture replaces current conversation (no multi-tab)
    - Empty state: instructions on how fixtures are added (JSON files in repo)

    Props:
    ```typescript
    interface FixtureBrowserProps {
      onSelectFixture: (fixture: Fixture) => void;
    }
    ```

    Implementation:
    - On mount, call `listFixtures()` to fetch fixture list. Show loading state while fetching.
    - Display a filter control: extract unique module names from fixtures, show as a dropdown/select element (or text input). "All modules" as default option.
    - Render each fixture as a clickable card/row showing:
      - Name (bold/prominent)
      - Module name (smaller, gray text)
      - Description (if available, truncated)
    - When a fixture is clicked, call `loadFixture(fixture.name)` to get full data, then call `onSelectFixture(fixture)` with the full fixture.
    - Show loading indicator while a fixture is being loaded.
    - Error state: if API call fails, show error message with retry button.
    - Empty state (no fixtures): "No fixtures available. Add JSON files to core/promptlab/fixtures/ to get started."

    Style with Tailwind following existing codebase patterns (stone/gray colors, rounded borders, clean spacing). This is an internal facilitator tool -- "minimal chrome, maximum utility" per user decision.
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-platform/ws2/web_frontend && npm run lint && npm run build` -- both must pass.
  </verify>
  <done>
    /promptlab page route exists with Layout wrapper. FixtureBrowser component fetches and displays fixtures with module filtering. Placeholder PromptLab view handles auth check and renders FixtureBrowser. Frontend builds without errors.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/penguin/code/lens-platform/ws2/web_frontend && npm run build` passes
2. `cd /home/penguin/code/lens-platform/ws2/web_frontend && npm run lint` passes
3. /promptlab page route exists (pages/promptlab/+Page.tsx)
4. API client exports all 4 functions with correct types
5. FixtureBrowser component renders fixture list with module filter
6. Auth check redirects unauthenticated users
</verification>

<success_criteria>
- Navigating to /promptlab renders the page (within the app Layout)
- Page title shows "Prompt Lab | Lens Academy"
- FixtureBrowser fetches fixture list from API and displays names/modules
- Module filter narrows the fixture list
- Clicking a fixture loads full data and triggers onSelectFixture callback
- API client handles both JSON responses and SSE streaming
- Frontend builds and lints clean
</success_criteria>

<output>
After completion, create `.planning/phases/06-chat-evaluation/06-03-SUMMARY.md`
</output>
