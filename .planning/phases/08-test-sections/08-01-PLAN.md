---
phase: 08-test-sections
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - web_frontend/src/components/module/TestSection.tsx
  - web_frontend/src/components/module/TestQuestionCard.tsx
  - web_frontend/src/components/module/__tests__/TestSection.test.tsx
  - web_frontend/src/types/course.ts
  - web_frontend/src/utils/sectionSlug.ts
  - web_frontend/src/utils/completionButtonText.ts
  - web_frontend/src/components/module/SectionDivider.tsx
  - web_frontend/src/components/module/StageProgressBar.tsx
  - web_frontend/src/views/Module.tsx
autonomous: true

must_haves:
  truths:
    - "Test section renders as a distinct section type in the module viewer"
    - "Test section has its own progress dot with a test-appropriate icon"
    - "Student sees a Begin screen with question count when viewing a test section"
    - "After clicking Begin, questions are revealed one at a time with a reveal button"
    - "Previous answered questions collapse when the next question is revealed"
    - "All questions use the existing AnswerBox component (same auto-save, voice, completion)"
    - "When all questions are completed, the test section is auto-marked as complete via progress API"
    - "On resume (page reload), already-answered questions appear collapsed and next unanswered question shows reveal button"
  artifacts:
    - path: "web_frontend/src/components/module/TestSection.tsx"
      provides: "Test section container with state machine (not_started -> in_progress -> completed)"
      min_lines: 80
    - path: "web_frontend/src/components/module/TestQuestionCard.tsx"
      provides: "Per-question wrapper with reveal button, collapse, and timer"
      min_lines: 50
    - path: "web_frontend/src/components/module/__tests__/TestSection.test.tsx"
      provides: "TDD tests for TestSection and TestQuestionCard DOM behavior"
      min_lines: 100
    - path: "web_frontend/src/types/course.ts"
      provides: "StageInfo.type union includes 'test'"
      contains: "test"
    - path: "web_frontend/src/views/Module.tsx"
      provides: "Test section rendering branch and stages mapping"
  key_links:
    - from: "web_frontend/src/views/Module.tsx"
      to: "web_frontend/src/components/module/TestSection.tsx"
      via: "section.type === 'test' rendering branch"
      pattern: "section\\.type === .test."
    - from: "web_frontend/src/components/module/TestSection.tsx"
      to: "web_frontend/src/components/module/TestQuestionCard.tsx"
      via: "renders TestQuestionCard per question"
    - from: "web_frontend/src/components/module/TestQuestionCard.tsx"
      to: "web_frontend/src/components/module/AnswerBox.tsx"
      via: "wraps existing AnswerBox component"
    - from: "web_frontend/src/components/module/TestSection.tsx"
      to: "web_frontend/src/api/assessments.ts"
      via: "batch getResponses for resume state"
      pattern: "getResponses"
    - from: "web_frontend/src/components/module/TestSection.tsx"
      to: "web_frontend/src/api/progress.ts"
      via: "markComplete on all questions answered"
      pattern: "markComplete"
---

<objective>
Create the TestSection component that groups multiple answer boxes within a test section, with Begin screen, sequential question reveal, collapse behavior, timer tracking, and resume support. Integrate it into Module.tsx as a new section rendering branch with proper progress dot and type support. Use TDD with React Testing Library to drive the implementation.

Purpose: This is the core test section UI -- the container component and its integration into the module viewer. Content hiding (dimming/blocking navigation during test) is handled in Plan 02. TDD ensures the state machine (not_started -> in_progress -> completed), sequential reveal logic, and resume state derivation are correct before wiring to production APIs.
Output: Test file, two new components (TestSection.tsx, TestQuestionCard.tsx), updated type system, and Module.tsx integration.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-test-sections/08-CONTEXT.md
@.planning/phases/08-test-sections/08-RESEARCH.md
@.planning/phases/07-answer-box/07-01-SUMMARY.md

Key files to read before implementing:
@web_frontend/src/views/Module.tsx (understand section rendering pattern, stages/stagesForDrawer useMemo, handleMarkComplete, MarkCompleteButton)
@web_frontend/src/components/module/AnswerBox.tsx (component interface and props)
@web_frontend/src/hooks/useAutoSave.ts (hook interface -- UseAutoSaveOptions, UseAutoSaveReturn)
@web_frontend/src/api/assessments.ts (getResponses API for batch loading)
@web_frontend/src/api/progress.ts (markComplete with content_type: "test")
@web_frontend/src/types/module.ts (TestSection type, QuestionSegment type, ModuleSegment union)
@web_frontend/src/types/course.ts (StageInfo type -- needs "test" added)
@web_frontend/src/components/module/StageProgressBar.tsx (StageIcon -- needs test icon)
@web_frontend/src/components/module/SectionDivider.tsx (needs "test" in type union)
@web_frontend/src/utils/sectionSlug.ts (needs "test" case)
@web_frontend/src/utils/completionButtonText.ts (needs test section handling)

Existing test patterns to follow:
@web_frontend/src/views/__tests__/Module.progress.test.tsx (mock patterns for useAuth, API modules, render + waitFor)
@web_frontend/vitest.config.ts (vitest + jsdom + @testing-library/jest-dom)
@web_frontend/src/test/setup.ts (global test setup)
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for TestSection and TestQuestionCard behavior</name>
  <files>
    web_frontend/src/components/module/__tests__/TestSection.test.tsx
    web_frontend/src/types/course.ts
    web_frontend/src/utils/sectionSlug.ts
    web_frontend/src/utils/completionButtonText.ts
    web_frontend/src/components/module/SectionDivider.tsx
    web_frontend/src/components/module/StageProgressBar.tsx
  </files>
  <action>
    First, update the type system and utilities so test infrastructure compiles (these are trivial non-behavioral changes needed for the test file to import correctly):

    1. **course.ts** - Add "test" to `StageInfo.type` union:
       ```ts
       type: "article" | "video" | "chat" | "lens-video" | "lens-article" | "page" | "test";
       ```

    2. **sectionSlug.ts** - Add case for "test" in `getSectionSlug`:
       ```ts
       case "test":
         title = section.meta?.title ?? null;
         break;
       ```

    3. **completionButtonText.ts** - Add early returns for test type in both `getCompletionButtonText` (return "") and `getSectionTextLength` (return 0).

    4. **SectionDivider.tsx** - Add "test" to the `type` prop union.

    5. **StageProgressBar.tsx** - Add a test icon to `StageIcon`. Use a checkmark SVG (low-key, not exam-like):
       ```tsx
       if (type === "test") {
         const size = small ? "w-4 h-4" : "w-5 h-5";
         return (
           <svg className={size} fill="currentColor" viewBox="0 0 20 20">
             <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
           </svg>
         );
       }
       ```

    Then create the test file `web_frontend/src/components/module/__tests__/TestSection.test.tsx`. Mock dependencies following the pattern from Module.progress.test.tsx:

    ```tsx
    import { describe, it, expect, vi, beforeEach } from "vitest";
    import { render, screen, waitFor } from "@testing-library/react";
    import userEvent from "@testing-library/user-event";
    ```

    Mock these modules:
    - `@/api/assessments` (getResponses) - returns responses per questionId
    - `@/api/progress` (markComplete) - returns completion response
    - `@/hooks/useAuth` - returns { isAuthenticated: true }
    - `@/components/module/AnswerBox` - mock AnswerBox as a simple div that renders the question text and provides a "Complete" button to simulate the onComplete callback. This lets us test TestSection's orchestration without AnswerBox internals.

    AnswerBox mock pattern:
    ```tsx
    vi.mock("@/components/module/AnswerBox", () => ({
      default: ({ onComplete, questionId }: any) => (
        <div data-testid={`answer-box-${questionId}`}>
          <button onClick={() => onComplete?.()}>Complete</button>
        </div>
      ),
    }));
    ```

    Create a helper that builds mock TestSection data:
    ```tsx
    function makeTestSection(questionCount: number) {
      return {
        type: "test" as const,
        contentId: null,
        learningOutcomeId: null,
        learningOutcomeName: null,
        meta: { title: "Unit Test" },
        segments: Array.from({ length: questionCount }, (_, i) => ({
          type: "question" as const,
          userInstruction: `Question ${i + 1} prompt`,
        })),
        optional: false,
      };
    }
    ```

    Write these test cases (ALL should FAIL since TestSection/TestQuestionCard don't exist yet):

    **describe("TestSection Begin screen")**
    - `it("shows question count on Begin screen")` - Render TestSection with 3 questions. Assert text "3 questions" is visible. Assert "Begin" button is visible.
    - `it("does not show any question content before Begin is clicked")` - Render with 3 questions. Assert "Question 1 prompt" is NOT in the document.

    **describe("TestSection sequential question reveal")**
    - `it("shows first question after clicking Begin")` - Render, click "Begin", wait for first question's answer box (data-testid="answer-box-...") to appear.
    - `it("shows only the first question initially, not subsequent ones")` - Render, click "Begin". Assert answer-box for question 1 is visible. Assert answer-box for question 2 is NOT in the document.
    - `it("reveals next question after completing current one")` - Render, click "Begin". Click "Complete" on the first answer-box. Assert answer-box for question 2 appears.
    - `it("collapses completed question")` - Render, click "Begin". Click "Complete" on Q1. Assert Q1 shows collapsed indicator (text "Answered" or a checkmark). Assert Q1's answer-box is NOT in the document.

    **describe("TestSection completion")**
    - `it("calls onTestComplete when all questions are answered")` - Render with onTestComplete mock. Click Begin, complete all questions. Assert onTestComplete was called.
    - `it("calls onMarkComplete with progress API when all questions done")` - Render with onMarkComplete mock. Complete all questions. Assert onMarkComplete was called.
    - `it("shows all questions as collapsed/completed after finishing")` - Complete all questions. Assert all questions show "Answered" text.

    **describe("TestSection resume")**
    - `it("skips Begin screen when responses already exist")` - Mock getResponses to return a completed response for Q1 and no response for Q2. Render. Assert "Begin" button is NOT visible. Assert Q1 shows collapsed "Answered" state. Assert a reveal button for Q2 is visible.
    - `it("shows completed state when all responses are complete")` - Mock getResponses to return completed responses for ALL questions. Render. Assert "Begin" is NOT visible. Assert all questions show "Answered" state.

    **describe("TestSection onTestStart callback")**
    - `it("calls onTestStart when Begin is clicked")` - Render with onTestStart mock. Click "Begin". Assert onTestStart was called.

    Each test should use `waitFor` for async operations (getResponses loading). Use `screen.getByText`, `screen.queryByText`, `screen.getByTestId`, `screen.queryByTestId` for assertions.

    After writing, run `cd /home/penguin/code/lens-platform/ws3/web_frontend && npx vitest run src/components/module/__tests__/TestSection.test.tsx 2>&1 | tail -40` -- tests should all FAIL (component files don't exist).

    Commit: `test(08-01): add failing tests for TestSection state machine and sequential reveal`
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-platform/ws3/web_frontend && npx vitest run src/components/module/__tests__/TestSection.test.tsx 2>&1 | tail -40`. All tests should FAIL (RED state). The test file itself should have no syntax or import errors -- failures should be because TestSection.tsx does not exist or doesn't render expected DOM.

    Also verify type system changes compile: `npx tsc --noEmit --pretty 2>&1 | head -30` -- no new errors from the utility updates.
  </verify>
  <done>
    Test file exists with 11+ failing test cases covering: Begin screen rendering, sequential reveal, collapse, completion callbacks, and resume state derivation. Type system recognizes "test" as a valid section type. All tests fail because implementation files don't exist yet (RED state).
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement TestSection and TestQuestionCard to pass all tests</name>
  <files>
    web_frontend/src/components/module/TestSection.tsx
    web_frontend/src/components/module/TestQuestionCard.tsx
  </files>
  <action>
    Create the two components to make all failing tests pass. Write the minimal implementation that satisfies the test assertions, then flesh out the full behavior.

    **TestQuestionCard.tsx** - Individual question wrapper with reveal, collapse, and timer:

    Props:
    ```ts
    interface TestQuestionCardProps {
      question: QuestionSegment;
      questionIndex: number;
      questionCount: number;
      isActive: boolean;       // Currently answering this question
      isCompleted: boolean;    // Already finished
      isRevealed: boolean;     // Has been shown (active or completed)
      moduleSlug: string;
      sectionIndex: number;
      segmentIndex: number;    // Actual segment index (for questionId)
      learningOutcomeId?: string | null;
      contentId?: string | null;
      isAuthenticated: boolean;
      onComplete: () => void;  // Called when student finishes this question
      initialText?: string;
      initialResponseId?: number | null;
      initialCompleted?: boolean;
    }
    ```

    Behavior:
    - If `!isRevealed`: render nothing (hidden question)
    - If `isCompleted` and `!isActive`: render collapsed state -- question number and "Answered" with checkmark, single line. Use CSS transition for smooth collapse.
    - If `isActive` and `isRevealed`: render the full question with AnswerBox. Build questionId = `moduleSlug:sectionIndex:segmentIndex`.
    - Timer: Start via useRef + setInterval when question becomes active and revealed. Record elapsed seconds. If `question.maxTime` is set, show subtle elapsed timer. If time expires, auto-submit. Timer does NOT resume on re-mount (per user decision).
    - For the "next question to reveal" state (active but not yet showing AnswerBox), show a reveal button: "Next question" (or "Begin" for first).

    **TestSection.tsx** - Container managing the state machine:

    Props:
    ```ts
    interface TestSectionProps {
      section: TestSectionType;
      moduleSlug: string;
      sectionIndex: number;
      isAuthenticated: boolean;
      onTestStart: () => void;
      onTestComplete: () => void;
      onMarkComplete: (response?: MarkCompleteResponse) => void;
    }
    ```

    State machine: `not_started | in_progress | completed`

    On mount (batch loading for resume):
    1. Extract question segments from `section.segments` (filter for `type === "question"`)
    2. Build mapping from question index to segment index
    3. For each question, compute questionId = `moduleSlug:sectionIndex:segmentIndex`
    4. Call `getResponses` for each questionId in parallel (Promise.all)
    5. Determine initial state:
       - ALL questions have responses with `completed_at` -> state = "completed"
       - ANY question has a response -> state = "in_progress", call `onTestStart()`
       - Else -> state = "not_started"
    6. Track completed question set, set currentQuestionIndex to first unanswered
    7. Store loaded response data for passing to children

    Begin screen (state = "not_started"):
    - Simple centered layout, casual feel
    - Show question count: "N questions" (e.g., "3 questions")
    - "Begin" button (not "Start test" -- too formal)
    - Minimal copy per user decision

    In-progress rendering (state = "in_progress"):
    - Render all questions as TestQuestionCard components
    - Track `currentQuestionIndex` and `completedQuestions` (Set<number>)
    - Pass appropriate isActive/isCompleted/isRevealed props:
      - isActive: index === currentQuestionIndex
      - isCompleted: completedQuestions.has(index)
      - isRevealed: index <= currentQuestionIndex or completedQuestions.has(index)
    - When a question completes:
      - Add to completedQuestions set
      - If all done: transition to "completed", call `onTestComplete()`, call `markComplete` progress API
      - Else: advance currentQuestionIndex

    Completed rendering (state = "completed"):
    - Show all questions in collapsed/completed state
    - No Begin screen, just the list of answered questions with checkmarks

    contentId for progress API: Generate deterministic ID `test:${moduleSlug}:${sectionIndex}`.

    Run tests after each significant piece. Iterate until all tests pass.
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-platform/ws3/web_frontend && npx vitest run src/components/module/__tests__/TestSection.test.tsx 2>&1 | tail -40`. All tests should PASS (GREEN state).

    Also run `npx tsc --noEmit --pretty 2>&1 | head -30` for type checking.

    Commit: `feat(08-01): implement TestSection and TestQuestionCard`
  </verify>
  <done>
    TestSection.tsx implements the full state machine (not_started/in_progress/completed) with Begin screen, batch response loading for resume, sequential question reveal, and auto-completion. TestQuestionCard.tsx wraps AnswerBox with reveal button, collapse behavior, and timer. All TDD tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate TestSection into Module.tsx and verify build</name>
  <files>
    web_frontend/src/views/Module.tsx
  </files>
  <action>
    Modify Module.tsx to render test sections and map them to progress dots:

    1. **Import TestSection** at top of file:
       ```ts
       import TestSection from "@/components/module/TestSection";
       ```

    2. **Update `stages` useMemo** (around line 390-454): Add "test" case. Use type assertion to pass a test-typed object:
       ```ts
       if (section.type === "test") {
         return {
           type: "test",
           source: "",
           from: null,
           to: null,
           title: section.meta?.title || "Test",
         } as unknown as Stage;
       }
       ```
       This works because StageIcon handles "test" as a string, and layout code only checks `optional`.

    3. **Update `stagesForDrawer` useMemo** (around line 457-488): Add test case:
       ```ts
       } else if (section.type === "test") {
         displayType = "test";
       }
       ```

    4. **Add test section rendering branch** in the sections.map() (around line 1005-1237). Before the final else clause:
       ```tsx
       : section.type === "test" ? (
         <TestSection
           section={section}
           moduleSlug={moduleId}
           sectionIndex={sectionIndex}
           isAuthenticated={isAuthenticated}
           onTestStart={() => {/* Phase 8 Plan 02 will add testModeActive */}}
           onTestComplete={() => {/* Phase 8 Plan 02 will add testModeActive */}}
           onMarkComplete={(response) => handleMarkComplete(sectionIndex, response)}
         />
       )
       ```

    5. **Skip MarkCompleteButton for test sections**:
       ```tsx
       {section.type !== "test" && (
         <MarkCompleteButton ... />
       )}
       ```

    6. **Add `isAuthenticated` from useAuth** if not already available in Module.tsx.

    Run full build and lint to confirm everything compiles.
  </action>
  <verify>
    Run `cd /home/penguin/code/lens-platform/ws3/web_frontend && npx tsc --noEmit --pretty 2>&1 | head -50` to confirm no type errors. Then run `npm run build 2>&1 | tail -20` and `npm run lint 2>&1 | tail -20` to confirm build and lint pass.

    Also re-run TDD tests: `npx vitest run src/components/module/__tests__/TestSection.test.tsx` -- should still pass.

    Commit: `feat(08-01): integrate TestSection into Module.tsx rendering`
  </verify>
  <done>
    Module.tsx renders test sections via the TestSection component. Test sections have a progress dot with test icon. MarkCompleteButton is skipped for test sections. Build, lint, and all TDD tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/penguin/code/lens-platform/ws3/web_frontend && npx vitest run src/components/module/__tests__/TestSection.test.tsx` -- all tests pass
2. `cd /home/penguin/code/lens-platform/ws3/web_frontend && npm run build` passes without errors
3. `cd /home/penguin/code/lens-platform/ws3/web_frontend && npm run lint` passes
4. TestSection.tsx exists and exports a default component
5. TestQuestionCard.tsx exists and exports a default component
6. StageInfo.type union includes "test"
7. StageIcon renders a distinct icon for type "test"
8. Module.tsx has a `section.type === "test"` rendering branch
9. MarkCompleteButton is NOT rendered for test sections
</verification>

<success_criteria>
- All TDD tests pass (Begin screen, sequential reveal, collapse, completion, resume)
- Test sections render as a distinct section type in Module.tsx
- Each test section has a single progress dot with a test icon
- Begin screen shows question count and a "Begin" button
- Questions are revealed sequentially with a reveal button
- Completed questions collapse to a single line
- Resume works: on page reload, test state is derived from existing responses
- Test section auto-marks complete when all questions are answered
- No TypeScript or build errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-test-sections/08-01-SUMMARY.md`
</output>
